Introduction
==============================================================================
This is the documentation for the command-line tool `sct_dbtool`. This tool
will apply custom checks into each item of the MRI database.

Installation
------------------------------------------------------------------------------
If you want, you can create a python environment with Anaconda::

    conda create -n dbtoolenv python=3.6
    source activate dbtoolenv

To install it, clone the repository and install with::

    cd sct_dbtool
    pip install .

.. note:: If you are developing, install it in development mode with
          `pip install -e .`, so changed mande in the source code
          will reflect automatically in your environment.

Configuration
------------------------------------------------------------------------------
Before running the tool, it must be configured with the database credentials,
in order to do that, just execute the following command below::

    sct_dbtool setup

And then answer the questions about the credentials for the Web Management
system.

How to use it
------------------------------------------------------------------------------
To use it, just run the following command::

    sct_dbtool sanity [PATH_DUKE]/sct_testing/large

Where the last parameter is the path to where the database files are. After
running it, the tool will generate a output report called `report.html` that
can be opened on any browser.

Implementing more checks
------------------------------------------------------------------------------
All sanity checks are implemented in :py:mod:`sct_dbtool.sanity` module. All
sanity checks should inherit from the class
:py:class:`.sanity.SanityCheck`. An example is the checking
:py:class:`.sanity.CheckEmptyDemographics` that will check
if the demographics field is present in each item of the database,
the code is shown below:

.. code-block:: python

    class CheckEmptyDemographics(SanityCheck):

        def __init__(self, db_path: str):
            super().__init__("warning", db_path)

        def check(self, item: Dict):
            if "demographic" not in item:
                self.add_diagnostic("Demographic field not present.", item)
                return

            if item["demographic"] is None:
                self.add_diagnostic("Demographic field is empty.", item)

As you can see, the class inherits from :py:class:`.sanity.SanityCheck`
and it implements two methods:

* :py:meth:`__init__()`: this is the class constructor, you should just
  specify the category of the check, which can be *warning*, *error* or
  *info*. And call the base class constructor with this argument
  and the `db_path` argument;

* :py:meth:`check()`: this is the method that implements the check itself.
  The `item` argument is a Python dictionary with the database item data.
  In the example above, we're just checking if the "demographic" field
  is present in this dictionary, and if not, it will call the method
  :py:meth:`.SanityCheck.add_diagnostic()` that will add a new diagnostic
  message for this item with a custom message.

  After adding a new class, the tool will automatically use this new
  class to check every database item in the next run of the `sct_dbtool sanity`
  checking. It will also add this class name as filter in the report as
  well as all diagnostic messages generated by this checking.

  If you need to refer any file in the file system, as used by other checks
  to check if the file mentioned in the database is present in the file system,
  you can just use the :py:attr:`.SanityCheck.db_path` object attribute, that contains
  the path of the file system that was passed as argument to the `sct_dbtool`.

Please check other examples in the module :py:mod:`sct_dbtool.sanity` for more information.





